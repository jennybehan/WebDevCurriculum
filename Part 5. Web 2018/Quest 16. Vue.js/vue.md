## 스터디 노트

### Topics

-   Components in web client development
-   Vue.js framework
-   Virtual DOM

### Checklist

#### Vue.js 는 어떤 특징을 가지고 있는 웹 프레임워크인가요?

-   MVVM 패턴에서 View Model(DOM Listener, Data Binding)에 해당하는 라이브러리 - 화면 요소들을 제어하는 코드와 데이터 제어 로직이 분리
-   컨트롤러가 없음 -> Controller 대신 라이프 사이클 메서드를 사용해서 단계별로 커스텀 로직을 수행한다.
-   컴포넌트 간에는 단방향 데이터 흐름 : `상위 속성이 업데이트되면 하위로 흐르게 되지만 그 반대는 안됩니다.`, 자녀 컴포넌트의 프로퍼티를 이용해 데이터를 전달한다.
    -   다만 v-model 등을 이용하면 데이터가 양방향으로 흐를 수 있다. -> 데이터에 있는 값이 뷰에 나타나고 이 뷰의 값이 바뀌면 데이터의 값도 바뀐다.
    -   폼에 입력한 값을 뷰 인스턴스의 데이터와 즉시 동기화 한다. 화면에 입력된 값을 저장하여 서버에 보내거나 watch 속성 등을 이용해서 추가 로직을 수행할 수 있다.(input, select, textarea 등)
-   Vue 객체를 생성할 때 `data`, `template`, `el`, `methods`, `life cycle callback` 등의 options 을 포함하여 작업
-   부모는 자식에게 props 로 데이터를 전달하고 자식은 부모에게 event 를 전달함
    -   props: 상위 컴포넌트에서 하위 컴포넌트로 값을 전달할 때 사용한다. 모든 컴포넌트가 각자의 스코프를 가지고 있기 때문에 하위 컴포넌트가 상위 컴포넌트의 값을 바로 참조할 수 없다.
-   데이터의 속성이 변하면 뷰에서도 화면을 갱신한다. (뷰모델에 자바스크립트 객체와 돔을 연결해 주면 뷰모델은 이 둘간의 동기화를 자동으로 처리)
-   라이프사이클 훅 중 동기적인 것과 비동기적인 메서드

    -   `this` 컨텍스트를 인스턴스에 자동으로 바인딩. `data`, `computed`, `method` 등에 접근 가능. arrow function 으로 작성하면 안됨
    -   \*beforeCreate
        -   호출 시점: 인스턴스 초기화 후, 감시자 설정 전
        -   동기적으로 호출
    -   \*created
        -   호출 시점: 인스턴스 작성된 후, 인스턴스의 옵션 처리 완료
        -   동기적으로 호출
        -   \*마운트가 시작되지 않아 `$el` 속성을 사용할 수는 없음
    -   beforeMount
        -   호출 시점: 마운트가 시작되기 바로 전, `render` 함수가 처음으로 호출
    -   mounted
        -   호출 시점: `el`이 `vm.$el`로 대체된 인스턴스가 마운트 된 직후 호출(??)
        -   모든 자식 컴포넌트가 마운트 된 상태를 보장하는 게 아님
    -   beforeUpdate
        -   데이터 변경시, 가상 DOM 재렌더링, 패치 전 호출
        -   더 많은 상태 변경이 있을 수 있으므로 추가로 렌더하지 않음
    -   update
        -   데이터가 변경되어 가상 DOM 이 재렌더링, 패치 되고난 후 호출
        -   computed 속성, watch 를 사용하는 게 더 나음
        -   모든 자식 컴포넌트가 재렌더링 된 상태를 보장하지 않음
    -   activated
        -   keep-alive 인 컴포넌트 활성화 시 호출됨
    -   deactivated
        -   keep-alive 인 컴포넌트가 비활성화 될 때 호출됨
    -   beforeDestroy
        -   Vue 인스턴스 제거 전 호출(어떤 상황에서 사용하지?)
    -   destroy
        -   Vue 인스턴스 제거 후 호출(디렉티브 바인딩, 이벤트 리스너, 하위 Vue 인스턴스 모두 제거)
    -   errorCaptured
        -   자손 컴포넌트로부터 에러가 캡쳐되었을 때 호출
        -   `(err: Error, vm: Component, info: string) => ?boolean`

#### Vue.js 에서의 컴포넌트란 무엇인가요?

-   Vue 인스턴스. 자체 뷰와 로직이 존재하는 컴포넌트.
-   자체적으로 유효범위가 존재하기 때문에 다른 컴포넌트의 값을 직접 접근할 수 없다. 따라서 같은 페이지 내에서도 데이터 공유가 불가능하다.
-   데이터나 이벤트를 전달할 수 있음
-   컴포넌트들은 `data` 객체를 통해 공통 데이터를 공유하고 `props`를 통해 상위 컴포넌트에서 하위 컴포넌트로 데이터를 넘겨준다.

#### 컴포넌트 간에 데이터를 주고받을 때 단방향 바인딩과 양방향 바인딩 방식이 어떻게 다르고, 어떤 장단점을 가지고 있나요?

-   단방향 바인딩: 컴포넌트 간에 데이터를 전달할 때 항상 상위 컴포넌트에서 하위 컴포넌트 방향으로만 전달하게 되어있는 흐름 / 데이터 -> 뷰의 형태로 바인딩이 되어 있어서 데이터의 값이 변하면 바로 업데이트가 된다.
    -   장단점: 데이터 흐름이 명확해서 파악하기 쉽다. 다만 컴포넌트 간에 데이터 전달을 하기 어렵다.
-   양방향 바인딩: 화면에 표시되는 값과 프레임워크의 모델 데이터 값이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경되는 흐름 / 뷰 <=> 데이터 형태로 바인딩하여 데이터가 양방향으로 흐르게 됨. 즉 데이터에 있는 값이 뷰에 나타나고, 이 뷰의 값이 바뀌면 데이터의 값도 바뀜
    -   장단점: 모델이 변경되면 뷰도 함께 변경되고, 뷰의 상태가 변경되면 모델의 상태도 함께 변경된다. 하지만 데이터 흐름이 복잡해지면서 변경되는 데이터를 감지하기 위한 성능 문제가 생긴다.

### Quest

-   Vue.js 를 통해 Quest 15 에서 만들었던 메모장 시스템을 다시 한 번 만들어 보세요.

    -   어떤 컴포넌트가 필요한지 생각해 보세요.
        -   NotePad(whole page), NoteList, Note(title, content)
    -   각 컴포넌트별로 해당하는 CSS 와 자바스크립트를 어떤 식으로 붙여야 할까요?
    -   컴포넌트간에 데이터를 주고받으려면 어떤 식으로 하는 것이 좋을까요?

        -   event bus 사용
        -   NotePad 가 부모, NoteList, Note 를 가지고 있음
        -   NoteList 는 Note 를 선택하며 title 값을 렌더링
        -   Note 는 title, content 값을 NoteList 에 업데이트 및 저장

    -   `vue-cli`와 같은 Vue 의 Boilterplating 기능을 이용하셔서 세팅하시면 됩니다.

-   **이제는 개발이 익숙해졌기 때문에 Skeleton code 를 제공하지 않습니다!**
    -   이제부터의 퀘스트는 디렉토리 내에 `submit` 폴더를 만들어 제출해 주시면 됩니다.
    -   서버쪽 코드가 필요할 경우 적절한 `package.json` 파일을 포함하여 제출해 주세요!
